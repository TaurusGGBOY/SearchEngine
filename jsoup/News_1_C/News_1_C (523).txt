回顾之前做的几个战斗 有所得 一 做法 为了更清晰 将游戏对象类拆分为两个类 如下 定义 纯粹的逻辑类 基本职责 对游戏对象的 逻辑值 进行定义 存储和计算 关键要素 只关心逻辑数据 不考虑渲染问题 如同在没有渲染能力的服务端写代码 不用继承 中 不在任何系统自带的组件上存取逻辑值 在逻辑运算的特定的位置抛出数据变更事件 举例说明 如定义 存储和计算 变换相关的坐标 旋转 缩放 战斗属性相关的 生命 法力 等 定义 纯粹的渲染类 基本职责 根据逻辑类中的数据 对物体进行实际显示更新 关键要素 持有实际的游戏物体 获得游戏物体的对象引用 持有对应的逻辑类 获得对应逻辑类的对象引用 渲染类监听逻辑类中的数据变更事件 并以此对要渲染的游戏对象及其子对象做显示更新 逻辑类和渲染类 是一种观察模式的单向弱依赖 举例说明 如监听事件 对 组件上的值进行修改 直接赋值或平滑插值 实际开发中 这两个类其实是可以合并为一个类的 只是要注意保持这种观察处理的方式 二 意义 为什么要将逻辑与渲染分离 清晰的数据模型 可拆卸的渲染逻辑 提高系统性能 渲染观察于逻辑 单向弱依赖 所以 能够随意销毁任何显示中的游戏物体 而不影响逻辑运算 逻辑类一直存在 只是干掉了观察者 对于 按视野显示游戏物体 分质量显示游戏物体 这样的性能优化需求 可以处理的得心应手 始终拥有安全可靠的数据 所有数据都是自己显式定义的 不存储在任何系统组件上 所以 能够避免 意想不到的被修改 比如被一些 类插件意外修改 能够为 帧同步中处理浮点数精度问题 提供基本条件 系统组件上的有些值是浮点数 逻辑值存储在组件上 将无法处理