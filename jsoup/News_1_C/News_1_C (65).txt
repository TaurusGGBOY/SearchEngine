在操作系统原理的术语中 线程是进程的一条执行路径 线程在 系统下 通常被称为轻量级的进程 线程虽然不是进程 但却可以看作是 进程的表亲 所有的线程都是在同一进程空间运行 这也意味着多条线程将共享该进程中的全部系统资源 如虚拟地址空间 文件描述符和信号处理等等 但同一进程中的多个线程有各自的调用栈 自己的寄存器环境 自己的线程本地存储 一个进程可以有很多线程 每条线程并行执行不同的任务 线程可以提高应用程序在多核环境下处理诸如文件 或者 等会产生堵塞的情况的表现性能 在 系统中 一个进程包含很多东西 包括可执行程序以及一大堆的诸如文件描述符地址空间等资源 在很多情况下 完成相关任务的不同代码间需要交换数据 如果采用多进程的方式 进程的创建所花的时间片要比线程大些 另外进程间的通信比较麻烦 需要在用户空间和内核空间进行频繁的切换 开销很大 但是如果使用多线程的方式 因为可以使用共享的全局变量 所以线程间的通信 数据交换 变得非常高效 多线程 主线程是你爸妈的房间 子线程是你的房间 你们要吃饼干 都只要在客厅里面拿就可以 多进程 你爸妈的房间在一层楼 你的房间在另外一层楼 两个房间的通信用 协议 我们用的 就是这种协议 所以多线程比多进程方便 因为你们在同一个房子里面 一个进程创建后 会首先生成一个缺省的线程 通常称这个线程为主线程 或称控制线程 程序中 主线程就是通过 函数进入的线程 由主线程调用 创建的线程称为子线程 子线程也可以有自己的入口函数 该函数由用户在创建的时候指定 每个线程都有自己的线程 可以通过 函数获取 最常见的线程模型中 除主线程较为特殊之外 其他线程一旦被创建 相互之间就是对等关系 不存在隐含的层次关系 每个进程可创建的最大线程数由具体实现决定 无论在 中还是 中 主线程和子线程的默认关系是 无论子线程执行完毕与否 一旦主线程执行完毕退出 所有子线程执行都会终止 这时整个进程结束或僵死 部分线程保持一种终止执行但还未销毁的状态 而进程必须在其所有线程销毁后销毁 这时进程处于僵死状态 线程函数执行完毕退出 或以其他非常方式终止 线程进入终止态 但是为线程分配的系统资源不一定释放 可能在系统重启之前 一直都不能释放 终止态的线程 仍旧作为一个线程实体存在于操作系统中 什么时候销毁 取决于线程属性 在这种情况下 主线程和子线程通常定义以下两种关系 线程的分离状态决定一个线程以什么样的方式来终止自己 在默认的情况下 线程是非分离状态的 这种情况下 原有的线程等待创建的线程结束 只有当 函数返回时 创建的线程才算终止 释放自己占用的系统资源 而分离线程没有被其他的线程所等待 自己运行结束了 线程也就终止了 马上释放系统资源 行和 行调用 函数用来创建了两个子线程 该函数的原型是 说明 用来创建一个线程 并执行第三个参数 所指向的函数 需要设定的是线程的分离状态 如果有必要也需要修改每个线程的栈大小 每个线程创建后默认是 状态 该状态需要主线程调用 等待它退出 否则子线程在结束时 内存资源不能得到释放造成内存泄漏 所以我们创建线程时一般会将线程设置为分离状态 具体有两种方法 代码 行我们定义了创建线程的属性变量 在对该属性进行设置前 我们需要先调用 函数初 始化它 第 行 在第 行我们设置线程的栈大小为 同时在第 行设置线程的属性为分离状态 第 行创建线程时使用了该属性创建线程 这时创建的子进程就是分离状态了 线程属性在使用完之后 我们应该调用 第 行 把他摧毁释放 而代码 行创建子线程时并没有使用该线程 同时在 里并没有调用 设置线程为分离状 态 这时就需要主线程在 行处调用 等待第二个子线程退出 当然主线程也就阻塞在这里不会往下继续执行 了 在创建两个线程时 我们都通过第四个参数将主线程 栈中的 变量地址传给了子线程 因为所有线程都是在同一进 程空间中运行 而只是子线程有自己独立的栈空间 所以这时所有子线程都可以访问主线程空间的 变量 现在我们编译运行一下程序看看效果 注意对于多线程编程在编译时 一定要加上 选项告诉链接器在链接的时候要连 接 库 主线程创建子线程后究竟是子线程还是主线程先执行 或究竟哪个子线程先运行系统并没有规定 这个依赖操作系统的进程 调度策略 当然因为代码 行处主线程调用了 会导致主线程阻塞 所以主线程不会往下继续执行 循环 我们再来深入分析各个线程的代码 我们在创建子线程之后 在子线程的执行函数里一般都会用 的死循环来让子线程一直运行 否则子线程将按代码顺序 执行 执行完毕就线程退出了 同样的 我们主线程也应该要用一个 循环一直运行 否则主线程退出会导致进程退出 而进程退出会导致所有子线程退出了 接下来我们在分析一下子线程所做的事 在两个子线程中做的任务是首先打印一下当前 变量的值然后让它自加 之后睡眠 后再打印一下这两个值 代码如下 从上面的运行结果红色标注的部分我们可以看到 在创建后首先开始运行 在开始自加之前值为初始值 然后让该值自加后休眠 秒后再打印该值发现不是 而是 了 这是由于 这个变量会被两个子线程同时访问修改导致 如果一个资源会被不同的线程访问修改 那么我们把这个资源叫做临界资源 那么对于该资源访问修改相关的代码就叫做临界区 那么怎么解决多个线程之间共享同一个共享资源 是多线程编程需要考虑的一个问题 试想一下 我们寝室 实验室只有一个洗手间 那多个人是怎么解决马桶共享的问题 对 那就是锁的机制 在这里马桶就是临界资源 我们在进入到洗手间 临界区 后 就首先上锁 然后用完离开洗手间 临界区 之后 把锁释放供别人使用 如果有人想去洗手间时发现门锁上了 他也有两种策略 在洗手间那里等 阻塞 暂时先离开等会再过来看 非阻塞 互斥锁 锁的是一个临界区 在临界区开头 加锁 在临界区结尾 关锁 如果多个线程要调用多个对象 则在上锁的时候可能会出现 死锁 举个例子 两个线程会同时使用到两个共享变量 和 同时每个变量都有自己相应的锁 和 这时 线程首先拿到 锁访问 接下来他需要拿 锁来访问变量 而如果此时 线程拿着 锁等待着 锁的话 就造成了线程 死锁 死锁产生的 个必要条件 以上四个条件均满足 必然会造成死锁 发生死锁的进程无法进行下去 它们所持有的资源也无法释放 这样会导致 的吞吐量下降 所以死锁情况是会浪费系统资源和影响计算机的使用性能的 那么 解决死锁问题就是相当有必要的了 产生死锁需要四个条件 那么 只要这四个条件中至少有一个条件得不到满足 就不可能发生死锁了 由于互斥条件是非共享资源所必须的 不仅不能改变 还应加以保证 所以 主要是破坏产生死锁的其他三个条件 方法 所有的进程在开始运行之前 必须一次性地申请其在整个运行过程中所需要的全部资源 优点 简单易实施且安全 缺点 因为某项资源不满足 进程无法启动 而其他已经满足了的资源也不会得到利用 严重降低了资源的利用率 造成 资源浪费 使进程经常发生饥饿现象 方法 该方法是对第一种方法的改进 允许进程只获得运行初期需要的资源 便开始运行 在运行过程中逐步释放掉分配到的已经使用完毕的资源 然后再去请求新的资源 这样的话 资源的利用率会得到提高 也会减少进程的饥饿问题 当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时 它必须释放已经保持的所有资源 待以后需要使用的时候再重新申请 这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了 该种方法实现起来比较复杂 且代价也比较大 释放已经保持的资源很有可能会导致进程之前的工作实效等 反复的申请和释放资源会导致进程的执行被无限的推迟 这不仅会延长进程的周转周期 还会影响系统的吞吐量 可以通过定义资源类型的线性顺序来预防 可将每个资源编号 当一个进程占有编号为 的资源时 那么它下一次申请资源只 能申请编号大于 的资源 多线程编程模型和多进程编程模型的工作方式完全一致 在了解 下多进程编程之后 我们就可以使用多进程编程模型改写 服务器的多线程实现 其流程图和程序代码如下 在多进程基础上写多线程