今天在开发的过程中需要把两个类似产品的代码进行合并，减少代码的维护量，同时可以减少物料的维护成本。 两个产品只是一个通信用结构体内的元素有些区别，结构体相同元素的便宜地址发生了变化，同时增加了一些元素。 在设计之初应该考虑到升级的问题，应该做到通信地址兼容，不改变原来的通信地址，但是由于前人已设计好了，且工程庞大，不易再修改。 在此基础上想到了，让程序动态的去动态的确定使用哪个结构体去使用，正好，这个结构体一个固定的便宜量中有一个产品ID能够用来区分是哪一种产品。这个恰好是反射机制，在此记录学习一下反射机制 计算机中的反射，是在运行的时候来自我检查，并对内部成员进行操作。就是说这个变量的类型可以动态的改变，在运行的时候确定它的作用，很多高级编程语言中有这些机制：Python，lua，c#，java都自带有这个机制。下面以lua作为例子 因为没有指定变量的类型，所以可以把任意类型赋值给他，在运行的时候检测当前的类型。 高级语言的反射机制，简单来说就是可以通过字符串型获取对应的类或者函数。但是c语言没有这个机制，需要自己动手来实现。 1）声明 2）调用 这种方式的不便之处在于，当需要映射的函数因分散在不同文件时，每增加一个新的映射都需要修改这个数组，以及头文件。 gcc支持通过使用__attribute__((section()))，将函数、变量放到指定的数据段中。 也就是说，可以让编译器帮我们完成1中向数组添加成员的动作。 借助此机制，回调函数可以在任意文件申明，不需要修改其他文件。 内核驱动初始化函数的遍历执行就采用了这种方法。 下面是init/main.c对于初始化函数的遍历调用 配合arch/xxx/kernel/vmlinux.lds 利用链接脚本可以得到每段的起始地址，然后在一段中遍历执行每一个初始化函数