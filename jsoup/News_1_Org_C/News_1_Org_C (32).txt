Those who dare to fail miserably can achieve greatly. 不怕惨败，才能有伟大的成就。C约翰・肯尼迪 参考文献： 活动是一种可以包含用户界面的组件，主要用于和用户进行交互。 活动提供应用程序绘制其UI的窗口。此窗口通常填充屏幕，但可能小于屏幕并浮动在其他窗口的顶部。通常，一个活动在应用程序中实现一个屏幕。例如，应用程序的某个活动可能会实现*“首选项”*屏幕，而另一个活动会实现“ *选择照片”*屏幕。 大多数应用程序包含多个屏幕，这意味着它们包含多个活动 通常，应用程序中的一个活动被指定为主要活动，这是用户启动应用程序时显示的第一个屏幕。然后，每个活动可以启动另一个活动以执行不同的操作。  所有的活动都要在AndroidManifest.xml中进行注册才能生效。活动的注册声明要放在<application>标签内，在<activity>标签中是晕了android：name来指定具体注册哪一个活动。 **配置主活动的方法**就是在<application>标签内加入<intent-filter>标签，并在这个标签内添加 You can use the manifest’s <activity> tag to control which apps can start a particular activity. A parent activity cannot launch a child activity unless both activities have the same permissions in their manifest. If you declare a<uses-permission> element for a particular activity, the calling activity must have a matching <uses-permission> element. 如果要允许调用SocialApp，您的应用必须与SocialApp清单中设置的权限相匹配 销毁活动只要按back键就可以，而且Activity类提供一个finish()方法，活动中调用这个方法就可以销毁当前活动。将前述的按钮监听器代码加入该方法即可。 Intent事Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间进行传递数据。被用于启动活动，启动服务以及发送广播等场景。 Activity类中提供一个startActivity()方法，专门用于启动活动，接受一个Intent参数，构建好的Intent传入该方法就可以启动目标活动了。创建一个新的Activity――SecondActivity。 不明确指出我们想要启动哪一个活动，指定了一系列更为抽象的action和category等信息，交由系统分析这个Intent，找出合适的Intent去启动。通过Intent的Intent-filter实现。 修改FirstActivity中按钮点击事件： 每个Intent只能指定一个action，但是却能指定多个category。可以调用Intent中的addCategory()方法来添加category。 使用隐式Intent不仅可以启动程序内的活动，还可以启动其他程序的活动，使得Android多个应用程序之间的功能共享成为了可能。 示例: Uri.parse将一个网址字符串解析成一个Uri对象。 如果自己创建一个活动，也可以响应打开网页的Intent。 新建Activity，编辑布局文件，在AndroidManifest.xml中修改ThirdActivity注册信息： 除了http协议外，可以指定很多其他协议，比如：geo表示显示地理位置，tel表示拨打电话。 一个app一般都是由多个Activity构成，这就涉及到多个Acitivity间数据传递。  Intent中提供了一些列putExtra()方法的重载，可以吧想要传递的数据暂存在Intent中，启动了另一个活动后，把这些数据从Intent中取出来就可以。 示例：在FirstActivity中修改点击按钮监听代码 修改SecondActivity中代码： Activity中还有一个startActivityForResult()方法也适用于启动活动，但是该方法期望活动销毁的时候返回一个结果给上一个活动。  该方法接收两个参数，一个是Intent，第二个参数是请求码，用于之后在回调中判断数据的来源。 首先修改FirstActivity中点击按钮监听事件代码： 其次修改SecondActivity中代码： 最后在FirstActivity中重写这个方法来得到返回数据： 如果是通过back键返回，则可以通过在SecondActivity中重写onBackPressed()来解决： Android中的活动是可以层叠的。每启动一个新的活动，就会覆盖原来的活动之上，点击Back键就会销毁最上面的活动。 Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也称作返回栈（Back Stack）。系统总是会显示处于栈顶活动给用户。  每个活动在其生命周期中最多可能会有4中状态： 运行状态： 活动位于返回栈的栈顶时，这时活动就处于运行状态。 暂停状态： 活动不处于栈顶时，但是仍然可见，活动就进入暂停状态。 停止状态： 活动不处于栈顶位置，且完全不可见，就进入停止状态。处于停止状态的活动有可能会被系统回收 销毁状态： 活动从返回栈中移除后就变成了销毁状态。 Activity类中定义了7种回调方法，覆盖了活动生命周期的每一个环节： 除了**onRestart()**方法之外，其他都是两两相对的，活动分为3中生存期：  onCreate()代码示例： 如果一个活动进入停止状态，有可能被系统回收，其中的数据在回收时可能得不到保存。 Activity中提供了一个onSaveInstanceState()回调方法，这个方法可以保证活动被回收之前一定被调用，可以通过这个方法来保存数据。 数据的取值可以在onCreate()方法中取出： 官方文档：横竖屏切换 参考文献一：gdutxiaoxu博客 参考文献二：菜鸟教程 参考文献三：横竖屏知识小结 App横竖屏切换的时候会销毁当前的Activity然后重新创建一个，你可以自行在生命周期 的每个方法里都添加打印Log的语句，来进行判断，又或者设一个按钮一个TextView点击按钮后，修改TextView 文本，然后横竖屏切换，会神奇的发现TextView文本变回之前的内容了！ 横竖屏切换时Activity走下述生命周期： onPause-> onStop-> onDestory-> onCreate->onStart->onResume 如果要禁止屏幕横竖屏自动切换，在AndroidManifest.xml中为Activity添加一个属性：android:screenOrientaiton 。。。 启动模式一共有4种，分别是：standard，singleTop，singleTask和singleInstance。可以再AndroidManifest.xml中通过<activity>标签指定android:launchMode属性来选择启动模式。 默认模式，每当启动一个新活动，就会在返回栈中入栈，并处于栈顶位置。该模式的活动无论这个活动是否在返回栈中存在，每次启动都会创建该活动的新实例。  当活动指定为singleTop模式，启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。  当活动的启动模式指定为singleTask，每次启动该活动系统首先会在返回栈中检查是否存在该活动的实例，如果发现就直接使用，并把这个活动之上的所有活动统统出栈。如果没有发现就创建一个新的活动实例。  指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。这种模式解决了其他程序和我们的程序共享一个活动的实例。  例如需要在某个界面上修改相关东西，快速定位该界面对应的活动 新建一个Java类：BaseActivity，继承AppCompatActivity,重写onCreate()方法。 在oncreate()方法中获取了当前实例的类名，然后将项目中所有活动的父类都不再继承AppCompatActivity，而是继承BaseActivity，这样查看日志，，每当进入一个活动的界面，该活动的类名就被打印出来。 按home键只是将程序挂起，并没有退出程序，如果程序需要一个注销或者退出的功能，只需要一个专门的集合类对所有的活动进行管理就可以。 新建一个ActivityCollector类作为活动管理器： 之后修改BaseActivity： 如果需要在某个地方退出程序，调用ActivityCollector.finishAll()方法就可以。 可以再销毁所有活动代码的后面加上杀掉当前进程，确保程序完全退出： 其中killProcess()方法用于杀掉一个进程，接收一个进程参数，通过myPid()方法可以获得当前程序的进程id。 如果你的模块需要将一些重要数据传递给另一个模块，例如两个字符串参数，但是你不清楚启动这个活动需要传递哪些数据，只需在启动活动添加一个actionStart()方法。 这时候如果想要启动该活动，只需一行代码就可以启动SecondActivity。