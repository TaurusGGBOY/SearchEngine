这次实验内容为了解php命令注入攻击的过程，掌握思路。 命令注入攻击（Command Injection），是指黑客通过利用HTML代码输入机制缺陷(例如缺乏有效验证限制的表格域)来改变网页的动态生成的内容。从而可以使用系统命令操作，实现使用远程数据来构造要执行的命令的操作。 PHP中可以使用下列四个函数来执行外部的应用程序或函数：system、exec、passthru、shell_exec。 信息来源――合天网安实验室 命令攻击为什么会形成漏洞？ 首先是因为应用需要调用一些执行系统命令的函数，比如上面说的php中的system等函数。其次，当用户能够控制这些函数中的参数，就可以将一些恶意的命令拼接到一个正常的命令当中，然后就会造成命令执行漏洞。 所以我们可以得出命令执行漏洞需要的条件： 通过命令执行漏洞，我们可以读写一些服务器上的文件，并且这些文件是不想让用户看到的，比如密码类的敏感文件。而且，我们可以通过命令打开服务器的远程服务，这样就可以拿到服务器的shell，从而操控服务器或者这个网页。再者，我们还可以对内网进行进一步的渗透。 下面开始实验。 从返回的结果来看服务器应该是windows系统，后面有补充。 服务器中关键代码如下： 程序获取GET参数ip，然后拼接到system（）函数中，利用system（）函数执行ping的功能，但是此处没有对参数ip进行过滤和检测，导致可以利用管道符执行其它的系统命令，后面有管道符的补充。 “|”在windows中的意思是：把前面的结果当成后面的输入，我们用ip=127.0.0.1|whoami来试一下 后面的命令执行成功，得到我们的身份是system “&”在windows中的意思是：两条命令一起执行，先执行前面再执行后面，我们用ip=127.0.0.1&whoami来试一下 可以看出whoami命令并没有成功被执行，原因是在ulr中，“&”是一个连接符号，会被转义成“%26”，那我们直接使用“%26”，它就会被转义成真正的“&”，所以我们不妨使用ip=127.0.0.1%26whoami再试一下 命令执行成功，可以看到服务器执行了两个命令（ping和whoami），我们的身份是system “||”在windows中的意思是：当前面一个执行失败，则执行后面的，我们用ip=127.0.0.1||whoami来试一下 这一次whoami命令并没有被执行，这是因为前面的命令可以执行，我们只要把前面的命令搞成不能执行的，让它自动执行下一条命令，根据前面提供的关键代码，我们知道只要传入了正常的ip地址，命令（ping）就会成功执行，所以我们试试把ip地址消除，用ip=||whoami来试一下 命令执行成功，我们的身份是system preg_match() 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。 preg_match() 匹配成功一次后就会停止匹配，如果要实现全部结果的匹配，则需使用 preg_match_all() 函数。 header()函数的作用是：发送一个原始 HTTP 标头[Http Header]到客户端。标头 (header) 是服务器以 HTTP 协义传 HTML 资料到浏览器前所送出的字串，在标头与 HTML 文件之间尚需空一行分隔。 这段代码对ip地址进行了简单的过滤，如果它匹配到，它会执行下面system那条命令，如果它没有匹配到，它就无法执行下面那条命令（即ping），也就是我们开始时看到的界面： 所以，我们想要让服务器执行ipconfig，首先想到的思路就是让它发生错误，执行失败，使用双管道让它执行ipconfig，接下来我们用ip=127.||ipconfig试一下： 成功 同理，我们使用单管道（ip=127.0.0.1|ipconfig）试一试： 成功 继续，我们使用“%26”（ip=127.0.0.1%26ipconfig）试一试： 执行了两个命令，成功！ 我们可以通过ping命令返回结果中的TTL项查看服务器的操作系统：LINUX――64 WIN2K/NT――128 WINDOWS系列――32 UNIX系列――255（前面为操作系统，后面为TTL值） 通过ping返回结果，看TTL值与哪项最为接近，服务器就是哪个操作系统。 我们ping一下百度的试试 TTL值为52，则它与64之间跨了12个路由，所以它的服务器应该是LINUX。 接下来补充一些常用的管道符： Windows系统支持的管道符如下： Linux系统支持的管道符如下： 总结一下：这种需要分析代码的问题一定不能大意，需要认真读懂什么意思才能破解它的秘密。这次实验并不是很难，以前在做CTF――Web题有遇到过，那种跟这个差不多，通过分析代码构造url获取flag。 如需转载，请注明原文出处，作者：vergilben